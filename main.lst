CCS PCM C Compiler, Version 5.015, 5967               26-May-19 22:02

               Filename:   C:\Users\quang\OneDrive\Desktop\CSS PIC C\shippingrobot_v0.2\shippingrobot\main.lst

               ROM used:   435 words (5%)
                           Largest free fragment is 2048
               RAM used:   14 (4%) at main() level
                           24 (7%) worst case
               Stack used: 2 locations
               Stack size: 8

*
0000:  MOVLW  01
0001:  MOVWF  0A
0002:  GOTO   17C
0003:  NOP
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
*
005A:  CLRF   77
005B:  CLRF   78
005C:  MOVF   2E,W
005D:  BCF    03.0
005E:  BTFSC  2F.0
005F:  ADDWF  77,F
0060:  RRF    77,F
0061:  RRF    78,F
0062:  BTFSC  2F.1
0063:  ADDWF  77,F
0064:  RRF    77,F
0065:  RRF    78,F
0066:  BTFSC  2F.2
0067:  ADDWF  77,F
0068:  RRF    77,F
0069:  RRF    78,F
006A:  BTFSC  2F.3
006B:  ADDWF  77,F
006C:  RRF    77,F
006D:  RRF    78,F
006E:  BTFSC  2F.4
006F:  ADDWF  77,F
0070:  RRF    77,F
0071:  RRF    78,F
0072:  BTFSC  2F.5
0073:  ADDWF  77,F
0074:  RRF    77,F
0075:  RRF    78,F
0076:  BTFSC  2F.6
0077:  ADDWF  77,F
0078:  RRF    77,F
0079:  RRF    78,F
007A:  BTFSC  2F.7
007B:  ADDWF  77,F
007C:  RRF    77,F
007D:  RRF    78,F
007E:  RETURN
*
00D3:  MOVF   2E,W
00D4:  XORWF  30,W
00D5:  ANDLW  80
00D6:  MOVWF  32
00D7:  BTFSS  2E.7
00D8:  GOTO   0DE
00D9:  COMF   2D,F
00DA:  COMF   2E,F
00DB:  INCF   2D,F
00DC:  BTFSC  03.2
00DD:  INCF   2E,F
00DE:  BTFSS  30.7
00DF:  GOTO   0E5
00E0:  COMF   2F,F
00E1:  COMF   30,F
00E2:  INCF   2F,F
00E3:  BTFSC  03.2
00E4:  INCF   30,F
00E5:  MOVLW  10
00E6:  MOVWF  31
00E7:  CLRF   77
00E8:  CLRF   7A
00E9:  RRF    2E,F
00EA:  RRF    2D,F
00EB:  BTFSS  03.0
00EC:  GOTO   0F3
00ED:  MOVF   2F,W
00EE:  ADDWF  77,F
00EF:  BTFSC  03.0
00F0:  INCF   7A,F
00F1:  MOVF   30,W
00F2:  ADDWF  7A,F
00F3:  RRF    7A,F
00F4:  RRF    77,F
00F5:  RRF    79,F
00F6:  RRF    78,F
00F7:  DECFSZ 31,F
00F8:  GOTO   0E9
00F9:  BTFSS  32.7
00FA:  GOTO   100
00FB:  COMF   78,F
00FC:  COMF   79,F
00FD:  INCF   78,F
00FE:  BTFSC  03.2
00FF:  INCF   79,F
*
0139:  MOVF   2E,W
013A:  XORWF  2F,W
013B:  ANDLW  80
013C:  MOVWF  31
013D:  BTFSS  2E.7
013E:  GOTO   141
013F:  COMF   2E,F
0140:  INCF   2E,F
0141:  BTFSS  2F.7
0142:  GOTO   145
0143:  COMF   2F,F
0144:  INCF   2F,F
0145:  MOVF   2F,W
0146:  CLRF   78
0147:  SUBWF  2E,W
0148:  BTFSC  03.0
0149:  GOTO   14D
014A:  MOVF   2E,W
014B:  MOVWF  77
014C:  GOTO   159
014D:  CLRF   77
014E:  MOVLW  08
014F:  MOVWF  30
0150:  RLF    2E,F
0151:  RLF    77,F
0152:  MOVF   2F,W
0153:  SUBWF  77,W
0154:  BTFSC  03.0
0155:  MOVWF  77
0156:  RLF    78,F
0157:  DECFSZ 30,F
0158:  GOTO   150
0159:  BTFSS  31.7
015A:  GOTO   15D
015B:  COMF   78,F
015C:  INCF   78,F
....................  
.................... #list 
....................  
.................... #fuses NOWDT, PUT, HS, NOPROTECT, NOLVP 
.................... #use delay(clock=20M) 
.................... #use rs232(baud=9600,xmit=pin_c6,rcv=pin_c7) 
....................  
.................... //#define LOW_SPEED 
.................... #define HIGH_SPEED 
.................... #include "global.h" 
.................... extern int line_sensor; 
.................... extern int destination; 
.................... extern int station; 
....................  
.................... #include "sensor.h" 
.................... #ifndef __SENSOR__ 
.................... #define __SENSOR__ 
.................... #include "global.h" 
.................... extern int line_sensor; 
.................... extern int destination; 
.................... extern int station; 
....................  
.................... /*#include "driver.h" 
.................... // d5 d6 d7 lll s1 s2 s3 
.................... void dk_line() 
.................... { 
....................    if(input(pin_d5)==0 && input(pin_d6)==0 && input(pin_d7)==0){ 
....................          dk_dc(0); 
....................       } 
....................    if(input(pin_d5)==1 && input(pin_d6)==0 && input(pin_d7)==1){ 
....................          dk_dc(0); 
....................       } 
....................    if(input(pin_d5)==0 && input(pin_d6)==0 && input(pin_d7)==1){ 
....................         dk_dc(-2); 
....................    } 
....................    if(input(pin_d5)==1 && input(pin_d6)==0 && input(pin_d7)==0){ 
....................          dk_dc(2); 
....................    } 
....................    if(input(pin_d5)==0 && input(pin_d6)==1 && input(pin_d7)==1){ 
....................         dk_dc(-2); 
....................    } 
....................    if(input(pin_d5)==1 && input(pin_d6)==1 && input(pin_d7)==0){ 
....................          dk_dc(2); 
....................    } 
.................... }*/ 
.................... int read_line_sensor() { 
....................    return (~input_a())&0x1f; 
*
004F:  MOVLW  FF
0050:  BSF    03.5
0051:  MOVWF  05
0052:  BCF    03.5
0053:  MOVF   05,W
0054:  XORLW  FF
0055:  ANDLW  1F
0056:  MOVWF  78
0057:  BCF    0A.3
0058:  BCF    0A.4
0059:  GOTO   1AC (RETURN)
.................... } 
.................... signed int distance() { 
....................    static signed int last_value = 0; 
....................    if (line_sensor == 0b00000100) { 
*
007F:  MOVF   20,W
0080:  SUBLW  04
0081:  BTFSS  03.2
0082:  GOTO   086
....................       return 0; 
0083:  MOVLW  00
0084:  MOVWF  78
0085:  GOTO   0B4
....................    } 
....................    if (line_sensor == 0b00010000) { 
0086:  MOVF   20,W
0087:  SUBLW  10
0088:  BTFSS  03.2
0089:  GOTO   08D
....................       return -3; 
008A:  MOVLW  FD
008B:  MOVWF  78
008C:  GOTO   0B4
....................    } 
....................    if (line_sensor == 0b00001100) { 
008D:  MOVF   20,W
008E:  SUBLW  0C
008F:  BTFSS  03.2
0090:  GOTO   094
....................       return -2; 
0091:  MOVLW  FE
0092:  MOVWF  78
0093:  GOTO   0B4
....................    } 
....................    if (line_sensor == 0b00001000) { 
0094:  MOVF   20,W
0095:  SUBLW  08
0096:  BTFSS  03.2
0097:  GOTO   09B
....................       return -1; 
0098:  MOVLW  FF
0099:  MOVWF  78
009A:  GOTO   0B4
....................    } 
....................    if (line_sensor == 0b00000010) { 
009B:  MOVF   20,W
009C:  SUBLW  02
009D:  BTFSS  03.2
009E:  GOTO   0A2
....................       return 1; 
009F:  MOVLW  01
00A0:  MOVWF  78
00A1:  GOTO   0B4
....................    } 
....................    if (line_sensor == 0b00000110) { 
00A2:  MOVF   20,W
00A3:  SUBLW  06
00A4:  BTFSS  03.2
00A5:  GOTO   0A9
....................       return 2; 
00A6:  MOVLW  02
00A7:  MOVWF  78
00A8:  GOTO   0B4
....................    } 
....................    if (line_sensor == 0b00000001) { 
00A9:  DECFSZ 20,W
00AA:  GOTO   0AF
....................       return 3; 
00AB:  MOVLW  03
00AC:  MOVWF  78
00AD:  GOTO   0B4
....................    } 
00AE:  GOTO   0B2
....................    else { 
....................       return last_value; 
00AF:  MOVF   23,W
00B0:  MOVWF  78
00B1:  GOTO   0B4
....................    } 
....................    last_value = line_sensor; 
00B2:  MOVF   20,W
00B3:  MOVWF  23
.................... } 
.................... #endif 
....................  
.................... #include "driver.h" 
.................... #ifndef __DRIVER__ 
.................... #define __DRIVER__ 
.................... static int overall_speed = 128; 
.................... // min 128, max 255; 
....................  
.................... const int kp = 50; 
.................... const int ki = 10; 
.................... const int kd = 20; 
....................  
.................... void set_speed(int speed) { 
....................    set_pwm1_duty(speed); 
*
0026:  MOVF   29,W
0027:  MOVWF  15
....................    set_pwm2_duty(speed); 
0028:  MOVF   29,W
0029:  MOVWF  1B
....................    overall_speed = speed; 
002A:  MOVF   29,W
002B:  MOVWF  24
002C:  BCF    0A.3
002D:  BCF    0A.4
002E:  GOTO   1A4 (RETURN)
.................... } 
.................... /*void dk_dc(signed int8 x) 
.................... { 
....................    if (x == 1) { 
....................       set_pwm1_duty(90); 
....................       set_pwm2_duty(90); 
....................    } 
....................    if(x==0){ 
....................    set_pwm1_duty(80); 
....................     set_pwm2_duty(80);} 
....................    if(x==-1){  
....................    set_pwm1_duty(15); 
....................    set_pwm2_duty(40);} 
....................    if(x==2){ 
....................    set_pwm1_duty(155); 
....................    set_pwm2_duty(0);} 
....................    if(x==-2){ 
....................    set_pwm1_duty(0); 
....................    set_pwm2_duty(120);} 
.................... }*/ 
....................  
.................... void forward() { 
....................    output_high(PIN_B1); 
002F:  BSF    03.5
0030:  BCF    06.1
0031:  BCF    03.5
0032:  BSF    06.1
....................    output_low(PIN_B2); 
0033:  BSF    03.5
0034:  BCF    06.2
0035:  BCF    03.5
0036:  BCF    06.2
....................    output_high(PIN_B3); 
0037:  BSF    03.5
0038:  BCF    06.3
0039:  BCF    03.5
003A:  BSF    06.3
....................    output_low(PIN_B4); 
003B:  BSF    03.5
003C:  BCF    06.4
003D:  BCF    03.5
003E:  BCF    06.4
003F:  BCF    0A.3
0040:  BCF    0A.4
0041:  GOTO   1A5 (RETURN)
.................... } 
....................  
.................... void back() { 
....................    output_low(PIN_B1); 
....................    output_high(PIN_B2); 
....................    output_low(PIN_B3); 
....................    output_high(PIN_B4); 
.................... } 
.................... void stop(){ 
....................    output_low(PIN_B1); 
....................    output_low(PIN_B2); 
....................    output_low(PIN_B3); 
....................    output_low(PIN_B4); 
.................... } 
.................... void turn (signed int vec) { 
....................    if (vec == 0) { 
*
011C:  MOVF   2C,F
011D:  BTFSS  03.2
011E:  GOTO   123
....................       set_pwm1_duty(overall_speed); 
011F:  MOVF   24,W
0120:  MOVWF  15
....................       set_pwm2_duty(overall_speed); 
0121:  MOVF   24,W
0122:  MOVWF  1B
....................    } 
....................    #ifdef HIGH_SPEED 
....................    if (abs(vec) > overall_speed) { 
0123:  MOVF   2C,W
0124:  BTFSS  2C.7
0125:  GOTO   128
0126:  MOVF   2C,W
0127:  SUBLW  00
0128:  MOVWF  77
0129:  BTFSC  77.7
012A:  GOTO   164
012B:  MOVF   77,W
012C:  SUBWF  24,W
012D:  BTFSC  03.0
012E:  GOTO   164
....................       vec = vec/abs(vec) * overall_speed; 
012F:  MOVF   2C,W
0130:  BTFSS  2C.7
0131:  GOTO   134
0132:  MOVF   2C,W
0133:  SUBLW  00
0134:  MOVWF  2D
0135:  MOVF   2C,W
0136:  MOVWF  2E
0137:  MOVF   2D,W
0138:  MOVWF  2F
*
015D:  MOVF   78,W
015E:  MOVWF  2E
015F:  MOVF   24,W
0160:  MOVWF  2F
0161:  CALL   05A
0162:  MOVF   78,W
0163:  MOVWF  2C
....................    } 
....................    if (vec > 0) { 
0164:  BTFSC  2C.7
0165:  GOTO   171
0166:  MOVF   2C,W
0167:  SUBLW  00
0168:  BTFSC  03.0
0169:  GOTO   171
....................       set_pwm1_duty(overall_speed); 
016A:  MOVF   24,W
016B:  MOVWF  15
....................       set_pwm2_duty(overall_speed - vec); 
016C:  MOVF   2C,W
016D:  SUBWF  24,W
016E:  MOVWF  2D
016F:  MOVWF  1B
....................    } 
0170:  GOTO   177
....................    else { 
....................       set_pwm1_duty(overall_speed + vec); 
0171:  MOVF   2C,W
0172:  ADDWF  24,W
0173:  MOVWF  2D
0174:  MOVWF  15
....................       set_pwm2_duty(overall_speed); 
0175:  MOVF   24,W
0176:  MOVWF  1B
....................    } 
....................    #endif 
....................     
....................    #ifdef LOW_SPEED 
....................    if (vec > 0) { 
....................       long pwm1 = overall_speed + vec; 
....................       int pwm2 = overall_speed; 
....................       if (pwm1 > 255) { 
....................          pwm2 -= pwm1 % 255; 
....................          pwm1 = 255; 
....................       } 
....................       set_pwm1_duty(pwm1); 
....................       set_pwm2_duty(pwm2); 
....................    } 
....................    if (vec < 0) { 
....................       int pwm1 = overall_speed; 
....................       long pwm2 = overall_speed - vec; 
....................       if (pwm2 > 255) { 
....................          pwm1 -= pwm2 % 255; 
....................          pwm2 = 255; 
....................       } 
....................       set_pwm1_duty(pwm1); 
....................       set_pwm2_duty(pwm2); 
....................    } 
....................    #endif 
....................     
.................... } 
....................  
.................... void pid_control() { 
*
00B4:  MOVF   78,W
00B5:  MOVWF  29
00B6:  MOVF   27,W
00B7:  SUBWF  29,W
00B8:  MOVWF  2A
....................    static signed long sum; 
*
0197:  BCF    03.5
0198:  CLRF   25
0199:  CLRF   26
....................    static signed int old_x; 
019A:  CLRF   27
....................    signed int x = distance(); 
....................    signed int error = x - old_x; 
....................    sum += error; 
*
00B9:  CLRF   7A
00BA:  MOVF   2A,W
00BB:  BTFSC  2A.7
00BC:  DECF   7A,F
00BD:  ADDWF  25,F
00BE:  MOVF   7A,W
00BF:  BTFSC  03.0
00C0:  INCFSZ 7A,W
00C1:  ADDWF  26,F
....................    signed int turn_angle = kp*x + ki*sum + kd*error; 
00C2:  MOVLW  32
00C3:  MOVWF  2E
00C4:  MOVF   29,W
00C5:  MOVWF  2F
00C6:  CALL   05A
00C7:  CLRF   2D
00C8:  MOVF   78,W
00C9:  MOVWF  2C
00CA:  BTFSC  2C.7
00CB:  DECF   2D,F
00CC:  CLRF   2E
00CD:  MOVLW  0A
00CE:  MOVWF  2D
00CF:  MOVF   26,W
00D0:  MOVWF  30
00D1:  MOVF   25,W
00D2:  MOVWF  2F
*
0100:  MOVF   79,W
0101:  MOVWF  7A
0102:  MOVF   78,W
0103:  ADDWF  2C,F
0104:  MOVF   79,W
0105:  BTFSC  03.0
0106:  INCFSZ 79,W
0107:  ADDWF  2D,F
0108:  MOVLW  14
0109:  MOVWF  2E
010A:  MOVF   2A,W
010B:  MOVWF  2F
010C:  CALL   05A
010D:  MOVF   78,W
010E:  CLRF   7A
010F:  MOVWF  77
0110:  BTFSC  77.7
0111:  DECF   7A,F
0112:  ADDWF  2C,W
0113:  MOVWF  78
0114:  MOVF   2D,W
0115:  BTFSC  03.0
0116:  INCFSZ 2D,W
0117:  ADDWF  7A,F
0118:  MOVF   78,W
0119:  MOVWF  2B
....................    turn(turn_angle); 
011A:  MOVF   2B,W
011B:  MOVWF  2C
....................    old_x = x; 
*
0177:  MOVF   29,W
0178:  MOVWF  27
0179:  BCF    0A.3
017A:  BCF    0A.4
017B:  GOTO   1AF (RETURN)
.................... } 
.................... #endif 
....................  
.................... #include "obstacle.h" 
.................... // header define function to avoid obstacle on the line 
.................... #ifndef __OBSTACLE__ 
.................... #define __OBSTACLE__ 
.................... void avoid_obstacle() { 
.................... } 
.................... #endif 
....................  
....................  
.................... #include "robot_state.h" 
.................... // check robot position and status 
.................... #include "global.h" 
.................... extern int line_sensor; 
.................... extern int destination; 
.................... extern int station; 
....................  
.................... #ifndef __ROBOT_STATE__ 
.................... #define __ROBOT_STATE__ 
....................  
.................... int is_at_station() { 
....................    if (line_sensor == 0b00011011) { 
....................       return 1; 
....................    } 
....................    else { 
....................       return 0; 
....................    } 
.................... } 
.................... int current_station() { 
....................     
....................    return 0; 
.................... } 
.................... void stop_at_destination() { 
....................  
.................... } 
....................  
.................... void return_to_start() { 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "esp_comm.h" 
.................... #ifndef __ESP_COMM__ 
.................... #define __ESP_COMM__ 
.................... int get_destination() { 
....................    if (kbhit()) { 
*
0042:  BTFSS  0C.5
0043:  GOTO   04A
....................       return getc() - 49;  
0044:  BTFSS  0C.5
0045:  GOTO   044
0046:  MOVF   1A,W
0047:  ADDLW  CF
0048:  MOVWF  78
0049:  GOTO   04C
....................    } 
....................    return -1; 
004A:  MOVLW  FF
004B:  MOVWF  78
004C:  BCF    0A.3
004D:  BCF    0A.4
004E:  GOTO   1A6 (RETURN)
.................... } 
.................... #endif 
....................  
....................  
.................... int line_sensor = 0; 
.................... int destination = 0; 
.................... int station = 0; 
.................... void init() { 
....................    set_tris_b(0x01); 
*
0004:  MOVLW  01
0005:  BSF    03.5
0006:  MOVWF  06
....................    port_b_pullups(1); 
0007:  BCF    01.7
....................    set_tris_a(0xff); 
0008:  MOVLW  FF
0009:  MOVWF  05
....................    setup_ccp1(CCP_PWM); 
000A:  BCF    03.5
000B:  BCF    28.2
000C:  MOVF   28,W
000D:  BSF    03.5
000E:  MOVWF  07
000F:  BCF    03.5
0010:  BCF    07.2
0011:  MOVLW  0C
0012:  MOVWF  17
....................    setup_ccp2(CCP_PWM); 
0013:  BCF    28.1
0014:  MOVF   28,W
0015:  BSF    03.5
0016:  MOVWF  07
0017:  BCF    03.5
0018:  BCF    07.1
0019:  MOVLW  0C
001A:  MOVWF  1D
....................    setup_timer_2(T2_DIV_BY_16, 255, 1); 
001B:  MOVLW  00
001C:  MOVWF  78
001D:  IORLW  06
001E:  MOVWF  12
001F:  MOVLW  FF
0020:  BSF    03.5
0021:  MOVWF  12
0022:  BCF    03.5
0023:  BCF    0A.3
0024:  BCF    0A.4
0025:  GOTO   19C (RETURN)
.................... } 
....................  
.................... int main() { 
*
017C:  MOVF   03,W
017D:  ANDLW  1F
017E:  MOVWF  03
017F:  MOVLW  81
0180:  BSF    03.5
0181:  MOVWF  19
0182:  MOVLW  A6
0183:  MOVWF  18
0184:  MOVLW  90
0185:  BCF    03.5
0186:  MOVWF  18
0187:  CLRF   23
0188:  MOVLW  80
0189:  MOVWF  24
018A:  CLRF   20
018B:  CLRF   21
018C:  CLRF   22
018D:  MOVLW  FF
018E:  MOVWF  28
018F:  BSF    03.5
0190:  BSF    1F.0
0191:  BSF    1F.1
0192:  BSF    1F.2
0193:  BCF    1F.3
0194:  MOVLW  07
0195:  MOVWF  1C
0196:  BCF    03.7
....................    init(); 
*
019B:  GOTO   004
....................     
....................    while (input(PIN_B0)) { 
019C:  BSF    03.5
019D:  BSF    06.0
019E:  BCF    03.5
019F:  BTFSC  06.0
01A0:  GOTO   19C
....................    } 
....................     
....................    set_speed(255); 
01A1:  MOVLW  FF
01A2:  MOVWF  29
01A3:  GOTO   026
....................    forward(); 
01A4:  GOTO   02F
....................     
....................    while (True) { 
....................       // wait for signal 
....................        
....................       destination = get_destination(); 
01A5:  GOTO   042
01A6:  MOVF   78,W
01A7:  MOVWF  21
....................       while ( !destination ) { 
01A8:  MOVF   21,F
01A9:  BTFSC  03.2
01AA:  GOTO   1A8
....................       } 
....................       line_sensor = read_line_sensor(); 
01AB:  GOTO   04F
01AC:  MOVF   78,W
01AD:  MOVWF  20
....................       /*signed int x = distance(); 
....................      */ 
....................       // control the robot follow the line 
....................       pid_control(); 
01AE:  GOTO   07F
01AF:  GOTO   1A5
....................        
....................       //avoid_obstacle(); 
....................  
....................      // stop_at_destination(); 
....................        
....................      // return_to_start(); 
....................        
....................      // stop(); 
....................        
....................       // destination = 0;  */ 
....................    } 
....................    return 0; 
01B0:  MOVLW  00
01B1:  MOVWF  78
.................... } 
....................  
01B2:  SLEEP
....................  
....................  

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
